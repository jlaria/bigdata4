<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Capítulo 4 Clústers basados en densidades | Introducción al aprendizaje no supervisado</title>
  <meta name="description" content="Capítulo 4 Clústers basados en densidades | Introducción al aprendizaje no supervisado" />
  <meta name="generator" content="bookdown 0.17 and GitBook 2.6.7" />

  <meta property="og:title" content="Capítulo 4 Clústers basados en densidades | Introducción al aprendizaje no supervisado" />
  <meta property="og:type" content="book" />
  
  
  
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Capítulo 4 Clústers basados en densidades | Introducción al aprendizaje no supervisado" />
  
  
  

<meta name="author" content="Juan C. Laria" />


<meta name="date" content="2020-03-04" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="som.html"/>
<link rel="next" href="aprendizaje-semi-supervisado.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/htmlwidgets-1.5.1/htmlwidgets.js"></script>
<script src="libs/plotly-binding-4.9.2/plotly.js"></script>
<script src="libs/typedarray-0.1/typedarray.min.js"></script>
<link href="libs/crosstalk-1.0.0/css/crosstalk.css" rel="stylesheet" />
<script src="libs/crosstalk-1.0.0/js/crosstalk.min.js"></script>
<link href="libs/plotly-htmlwidgets-css-1.52.2/plotly-htmlwidgets.css" rel="stylesheet" />
<script src="libs/plotly-main-1.52.2/plotly-latest.min.js"></script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Aprendizaje no supervisado</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introducción</a></li>
<li class="chapter" data-level="1" data-path="kmeans.html"><a href="kmeans.html"><i class="fa fa-check"></i><b>1</b> Clústers partitivos</a><ul>
<li class="chapter" data-level="1.1" data-path="kmeans.html"><a href="kmeans.html#k-medias"><i class="fa fa-check"></i><b>1.1</b> K medias</a></li>
<li class="chapter" data-level="1.2" data-path="kmeans.html"><a href="kmeans.html#librería-factoextra"><i class="fa fa-check"></i><b>1.2</b> Librería <code>factoextra</code></a></li>
<li class="chapter" data-level="1.3" data-path="kmeans.html"><a href="kmeans.html#variación-de-información"><i class="fa fa-check"></i><b>1.3</b> Variación de información</a></li>
<li class="chapter" data-level="1.4" data-path="kmeans.html"><a href="kmeans.html#minibatch-kmeans"><i class="fa fa-check"></i><b>1.4</b> Minibatch kmeans</a></li>
<li class="chapter" data-level="1.5" data-path="kmeans.html"><a href="kmeans.html#k-mediano"><i class="fa fa-check"></i><b>1.5</b> K mediano</a><ul>
<li class="chapter" data-level="1.5.1" data-path="kmeans.html"><a href="kmeans.html#custerrclara"><i class="fa fa-check"></i><b>1.5.1</b> <code>CusterR::clara</code></a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path="kmeans.html"><a href="kmeans.html#selección-de-k"><i class="fa fa-check"></i><b>1.6</b> Selección de K</a><ul>
<li class="chapter" data-level="1.6.1" data-path="kmeans.html"><a href="kmeans.html#método-del-codo"><i class="fa fa-check"></i><b>1.6.1</b> Método del codo</a></li>
<li class="chapter" data-level="1.6.2" data-path="kmeans.html"><a href="kmeans.html#método-average-silhouette"><i class="fa fa-check"></i><b>1.6.2</b> Método average silhouette</a></li>
<li class="chapter" data-level="1.6.3" data-path="kmeans.html"><a href="kmeans.html#método-gap-statistic"><i class="fa fa-check"></i><b>1.6.3</b> Método Gap statistic</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="clústers-jerárquicos.html"><a href="clústers-jerárquicos.html"><i class="fa fa-check"></i><b>2</b> Clústers jerárquicos</a><ul>
<li class="chapter" data-level="2.1" data-path="clústers-jerárquicos.html"><a href="clústers-jerárquicos.html#hclust"><i class="fa fa-check"></i><b>2.1</b> <code>hclust</code></a><ul>
<li class="chapter" data-level="2.1.1" data-path="clústers-jerárquicos.html"><a href="clústers-jerárquicos.html#distancias.-qué-hace-la-función-dist"><i class="fa fa-check"></i><b>2.1.1</b> Distancias. ¿Qué hace la función <code>dist</code>?</a></li>
<li class="chapter" data-level="2.1.2" data-path="clústers-jerárquicos.html"><a href="clústers-jerárquicos.html#linkages.-qué-especifica-el-parámetro-method-en-la-función-hclust"><i class="fa fa-check"></i><b>2.1.2</b> Linkages. ¿Qué especifica el parámetro <code>method</code> en la función <code>hclust</code>?</a></li>
<li class="chapter" data-level="2.1.3" data-path="clústers-jerárquicos.html"><a href="clústers-jerárquicos.html#los-métodos-cutree-y-rect.hclust"><i class="fa fa-check"></i><b>2.1.3</b> Los métodos <code>cutree</code> y <code>rect.hclust</code></a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="clústers-jerárquicos.html"><a href="clústers-jerárquicos.html#librería-protoclust"><i class="fa fa-check"></i><b>2.2</b> Librería <code>protoclust</code></a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="som.html"><a href="som.html"><i class="fa fa-check"></i><b>3</b> Self Organizing Maps</a><ul>
<li class="chapter" data-level="3.1" data-path="som.html"><a href="som.html#librería-kohonen"><i class="fa fa-check"></i><b>3.1</b> Librería <code>kohonen</code></a><ul>
<li class="chapter" data-level="3.1.1" data-path="som.html"><a href="som.html#u-matrix"><i class="fa fa-check"></i><b>3.1.1</b> U-Matrix</a></li>
<li class="chapter" data-level="3.1.2" data-path="som.html"><a href="som.html#clusters"><i class="fa fa-check"></i><b>3.1.2</b> Clusters</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="clústers-basados-en-densidades.html"><a href="clústers-basados-en-densidades.html"><i class="fa fa-check"></i><b>4</b> Clústers basados en densidades</a><ul>
<li class="chapter" data-level="4.1" data-path="clústers-basados-en-densidades.html"><a href="clústers-basados-en-densidades.html#librería-dbscan"><i class="fa fa-check"></i><b>4.1</b> Librería <code>dbscan</code></a><ul>
<li class="chapter" data-level="4.1.1" data-path="clústers-basados-en-densidades.html"><a href="clústers-basados-en-densidades.html#cómo-funciona"><i class="fa fa-check"></i><b>4.1.1</b> ¿Cómo funciona?</a></li>
<li class="chapter" data-level="4.1.2" data-path="clústers-basados-en-densidades.html"><a href="clústers-basados-en-densidades.html#ventajas"><i class="fa fa-check"></i><b>4.1.2</b> Ventajas</a></li>
<li class="chapter" data-level="4.1.3" data-path="clústers-basados-en-densidades.html"><a href="clústers-basados-en-densidades.html#utilización"><i class="fa fa-check"></i><b>4.1.3</b> Utilización</a></li>
<li class="chapter" data-level="4.1.4" data-path="clústers-basados-en-densidades.html"><a href="clústers-basados-en-densidades.html#determinando-el-eps-óptimo."><i class="fa fa-check"></i><b>4.1.4</b> Determinando el <code>eps</code> óptimo.</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="aprendizaje-semi-supervisado.html"><a href="aprendizaje-semi-supervisado.html"><i class="fa fa-check"></i><b>5</b> Aprendizaje semi-supervisado</a><ul>
<li class="chapter" data-level="5.1" data-path="aprendizaje-semi-supervisado.html"><a href="aprendizaje-semi-supervisado.html#librería-s2net"><i class="fa fa-check"></i><b>5.1</b> Librería <code>s2net</code></a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="hyperparam.html"><a href="hyperparam.html"><i class="fa fa-check"></i><b>6</b> Selección de hiperparámetros</a><ul>
<li class="chapter" data-level="6.1" data-path="hyperparam.html"><a href="hyperparam.html#librerías-tune-y-dials"><i class="fa fa-check"></i><b>6.1</b> Librerías <code>tune</code> y <code>dials</code></a><ul>
<li class="chapter" data-level="6.1.1" data-path="hyperparam.html"><a href="hyperparam.html#grid-search"><i class="fa fa-check"></i><b>6.1.1</b> Grid search</a></li>
<li class="chapter" data-level="6.1.2" data-path="hyperparam.html"><a href="hyperparam.html#random-search"><i class="fa fa-check"></i><b>6.1.2</b> Random Search</a></li>
<li class="chapter" data-level="6.1.3" data-path="hyperparam.html"><a href="hyperparam.html#optimización-bayesiana"><i class="fa fa-check"></i><b>6.1.3</b> Optimización Bayesiana</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Introducción al aprendizaje no supervisado</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="clústers-basados-en-densidades" class="section level1">
<h1><span class="header-section-number">Capítulo 4</span> Clústers basados en densidades</h1>
<div id="librería-dbscan" class="section level2">
<h2><span class="header-section-number">4.1</span> Librería <code>dbscan</code></h2>
<p>DBSCAN (Density-Based Spatial Clustering and Application with Noise) es un algoritmo de cluster basado en densidades, que puede ser utilizado para identificar clusters que contengan patrones, ruido y outliers. Mediante la grupación basada en densidades, se localizan áreas de mayor densidad con respecto al resto de los datos. Los puntos que quedan fuera de estas áreas de densidad son considerados ruido o puntos de frontera.</p>
<p>Si quisiéramos enseñar a una máquina a “observar” patrones como los seres humanos lo hacemos, probablemente deberíamos comenzar plantéandonos un método como DBSCAN.</p>
<p>El algoritmo DBSCAN se basa en la noción intuitiva detrás de lo que es cluster y lo que es ruido. Para los puntos que pertenecen a un cluster, hay una “vecindad” de radio dado, tal que esta vecindad contiene un número mínimo de puntos que también pertenecen al mismo cluster.</p>
<p>Por ejemplo, la siguiente imagen puede ser fácilmente segnemtada por un ser humano con una simple pasada. ¿Pudiésemos utilizar análisis cluster para determinar quiénes son los personajes de esta historia?</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb89-1" title="1"><span class="kw">library</span>(dplyr)</a>
<a class="sourceLine" id="cb89-2" title="2"><span class="kw">library</span>(ggplot2)</a>
<a class="sourceLine" id="cb89-3" title="3"></a>
<a class="sourceLine" id="cb89-4" title="4">points =<span class="st"> </span><span class="kw">read.table</span>(<span class="dt">file =</span> <span class="st">&quot;data/arte-rupestre.txt&quot;</span>,</a>
<a class="sourceLine" id="cb89-5" title="5">                    <span class="dt">header =</span> T)</a>
<a class="sourceLine" id="cb89-6" title="6"><span class="kw">ggplot</span>(points, <span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y)) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb89-7" title="7"><span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="fl">0.5</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb89-8" title="8"><span class="st">  </span><span class="kw">theme_void</span>()</a></code></pre></div>
<p><img src="bookdown-demo_files/figure-html/unnamed-chunk-61-1.png" width="672" /></p>
<p>Veamos qué sucede si intentamos particionar estos puntos usando k-means.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb90-1" title="1"><span class="kw">library</span>(factoextra)</a>
<a class="sourceLine" id="cb90-2" title="2"></a>
<a class="sourceLine" id="cb90-3" title="3"><span class="kw">set.seed</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb90-4" title="4">km.res =<span class="st"> </span><span class="kw">kmeans</span>(points, <span class="dv">3</span>, <span class="dt">nstart =</span> <span class="dv">9</span>)</a>
<a class="sourceLine" id="cb90-5" title="5"><span class="kw">fviz_cluster</span>(km.res, points, <span class="dt">geom =</span> <span class="st">&quot;point&quot;</span>, </a>
<a class="sourceLine" id="cb90-6" title="6">             <span class="dt">ellipse =</span> F, <span class="dt">show.clust.cent =</span> F, </a>
<a class="sourceLine" id="cb90-7" title="7">             <span class="dt">palette=</span><span class="st">&quot;jco&quot;</span>, <span class="dt">ggtheme =</span> <span class="kw">theme_classic</span>() )</a></code></pre></div>
<p><img src="bookdown-demo_files/figure-html/unnamed-chunk-62-1.png" width="672" /></p>
<p>Como podemos observar, k-means no identifica apropiadamente estos clusters con formas arbitrarias, incluso cuando le decimos exactamente cuántos grupos verdaderos hay.</p>
<div id="cómo-funciona" class="section level3">
<h3><span class="header-section-number">4.1.1</span> ¿Cómo funciona?</h3>
<p>El objetivo de DBSCAN es identificar regiones densas, que pueden ser medidas según el número de objetos cercanos a un punto dado.</p>
<p>DBSCAN requiere dos hiperparámetros importantes,</p>
<ul>
<li><strong>epsilon</strong> (<code>eps</code>) Define el radio de la vecindad alrededor de un punto <span class="math inline">\(x\)</span>, comúnmente llamada <span class="math inline">\(\epsilon-\)</span>vecindad.</li>
<li><strong>minimum points</strong> (<code>minPts</code>) Número mínimo de vecinos en un radio <code>eps</code>.</li>
</ul>
<p>Esto da lugar a una clasificación en tres tipos de puntos. Dado <span class="math inline">\(x\)</span> que pertenece al conjunto de datos,</p>
<ul>
<li><span class="math inline">\(x\)</span> es un punto <strong>interior</strong> si tiene más de <code>minPts</code> puntos en su <span class="math inline">\(\epsilon-\)</span>vecindad.</li>
<li><span class="math inline">\(x\)</span> es un punto <strong>frontera</strong> si no es interior, pero pertenece a la <span class="math inline">\(\epsilon-\)</span>vecindad de algún punto interior.</li>
<li><span class="math inline">\(x\)</span> es un <strong>outlier</strong> si no es punto interior ni frontera.</li>
</ul>
<p>La siguiente figura muestra los diferentes tipos de puntos que podemos tener. En este ejemplo, <span class="math inline">\(x\)</span> es un punto interior (porque tiene 6 puntos a distancia menor que <code>eps</code>), <span class="math inline">\(y\)</span> es un punto frontera (porque pertenece a la <span class="math inline">\(\epsilon-\)</span>vecindad de <span class="math inline">\(x\)</span>) y <span class="math inline">\(z\)</span> es un outlier.</p>
<p><img src="gfx/dbscan-principle.png" /></p>
<p>El algoritmo DBSCAN se basa en las siguientes nociones de conectividad entre puntos.</p>
<ul>
<li><p><strong>Direct density reachable</strong> (<span class="math inline">\(\rightarrow\)</span>) Decimos que <span class="math inline">\(B \rightarrow A\)</span> si</p>
<ol style="list-style-type: lower-roman">
<li><span class="math inline">\(A\)</span> pertenece a la <span class="math inline">\(\epsilon-\)</span>vecindad de <span class="math inline">\(B\)</span></li>
<li><span class="math inline">\(B\)</span> es un punto <strong>interior</strong></li>
</ol></li>
<li><strong>Density reachable</strong> (<span class="math inline">\(\rightarrow \cdot \rightarrow\)</span>) Decimos que <span class="math inline">\(B \rightarrow \cdot \rightarrow A\)</span> si existe un conjunto de puntos interiores que lleva de <span class="math inline">\(B\)</span> a <span class="math inline">\(A\)</span>.</li>
<li><p><strong>Density connected</strong> <span class="math inline">\(A\)</span> y <span class="math inline">\(B\)</span> son density connected si existe un punto interior <span class="math inline">\(C\)</span> tal que <span class="math inline">\(B \leftarrow \cdot \leftarrow C \rightarrow \cdot \rightarrow A\)</span>.</p></li>
</ul>
<p>Un <strong>cluster</strong> basado en densidad se define como un conjunto de puntos density connected.
La idea del algoritmo DBSCAN es la siguiente.</p>
<ol style="list-style-type: decimal">
<li>Para un punto inicial <span class="math inline">\(x_0\)</span> encontrar todos los puntos en su <span class="math inline">\(\epsilon-\)</span>vecindad. Cada punto con un número de vecinos mayor o igual que <code>minPts</code> es marcado como <strong>interior</strong>, de lo contrario es marcado como <strong>visitado</strong>.</li>
<li>Para cada punto interior, si este no está en ningún cluster, crear un nuevo cluster. Recursivamente, encontrar todos los puntos density connected con él, y asignarlos a su mismo clúster.</li>
<li>Iterar 1-2 en los puntos restantes <strong>no visitados</strong>.</li>
<li>Los puntos que no pertenecen a ningún cluster son marcados como outliers.</li>
</ol>
<p>Visualización paso a paso: <a href="https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/" class="uri">https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/</a></p>
</div>
<div id="ventajas" class="section level3">
<h3><span class="header-section-number">4.1.2</span> Ventajas</h3>
<ol style="list-style-type: decimal">
<li>A diferencia de k-means, DBSCAN no requiere un número prefijado de clusters.</li>
<li>DBSCAN puede lidiar con cualquier forma en los clústers, no necesariamente circular.</li>
<li>DBSCAN identifica los outliers.</li>
</ol>
</div>
<div id="utilización" class="section level3">
<h3><span class="header-section-number">4.1.3</span> Utilización</h3>
<p>La función <code>dbscan</code>, del paquete del mismo nombre, es una implementación optimizada del algoritmo DBSCAN.</p>
<p>Para comprobar si el paquete no está instalado e instalarlo, ejecutamos la línea siguiente.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb91-1" title="1"><span class="cf">if</span>(<span class="op">!</span><span class="kw">require</span>(<span class="st">&quot;dbscan&quot;</span>))<span class="kw">install.packages</span>(<span class="st">&quot;dbscan&quot;</span>)</a></code></pre></div>
<p>Vamos a aplicar el algoritmo DBSCAN al conjunto de puntos de nuestro ejemplo.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb92-1" title="1"><span class="kw">library</span>(dbscan)</a>
<a class="sourceLine" id="cb92-2" title="2">db =<span class="st"> </span><span class="kw">dbscan</span>(points, <span class="dt">eps =</span> <span class="dv">15</span>, <span class="dt">minPts =</span> <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb92-3" title="3"><span class="kw">fviz_cluster</span>(db, <span class="dt">data=</span>points, <span class="dt">stand =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb92-4" title="4">             <span class="dt">ellipse =</span> <span class="ot">FALSE</span>, <span class="dt">show.clust.cent =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb92-5" title="5">             <span class="dt">geom =</span> <span class="st">&quot;point&quot;</span>,<span class="dt">palette =</span> <span class="st">&quot;jco&quot;</span>, <span class="dt">ggtheme =</span> <span class="kw">theme_classic</span>())</a></code></pre></div>
<p><img src="bookdown-demo_files/figure-html/unnamed-chunk-64-1.png" width="672" /></p>
<p>Ups! DBSCAN solamente identifica un cluster en este ejemplo. Veamos si podemos encontrar los hiperparámetros <code>eps</code> y <code>minPts</code> óptimos.</p>
</div>
<div id="determinando-el-eps-óptimo." class="section level3">
<h3><span class="header-section-number">4.1.4</span> Determinando el <code>eps</code> óptimo.</h3>
<p>El método para determinar el mejor <code>eps</code>consiste en, fijado el valor de <code>minPts</code>, calcular la distancia media de cada punto a sus <span class="math inline">\(k=\)</span><code>minPts</code> vecinos más cercanos. Luego este promedio para cada punto es mostrado en orden ascendente, y el valor de <code>eps</code> se escoje mirando el primer codo.</p>
<p>En nuestro ejemplo,</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb93-1" title="1">dist &lt;-<span class="st"> </span><span class="kw">kNNdist</span>(points, <span class="dt">k=</span><span class="dv">10</span>)</a>
<a class="sourceLine" id="cb93-2" title="2">dist &lt;-<span class="st"> </span><span class="kw">sort</span>(dist)</a>
<a class="sourceLine" id="cb93-3" title="3"></a>
<a class="sourceLine" id="cb93-4" title="4"><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb93-5" title="5"><span class="st">  </span><span class="kw">aes</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(dist), <span class="dt">y =</span> dist) <span class="op">+</span></a>
<a class="sourceLine" id="cb93-6" title="6"><span class="st">  </span><span class="kw">geom_line</span>()<span class="op">+</span></a>
<a class="sourceLine" id="cb93-7" title="7"><span class="st">  </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">6</span>, <span class="dt">linetype =</span> <span class="st">&quot;dashed&quot;</span>)</a></code></pre></div>
<p><img src="bookdown-demo_files/figure-html/unnamed-chunk-65-1.png" width="576" /></p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb94-1" title="1"><span class="kw">library</span>(dbscan)</a>
<a class="sourceLine" id="cb94-2" title="2">db =<span class="st"> </span><span class="kw">dbscan</span>(points, <span class="dt">eps =</span> <span class="dv">6</span>, <span class="dt">minPts =</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb94-3" title="3"><span class="kw">fviz_cluster</span>(db, <span class="dt">data=</span>points, <span class="dt">stand =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb94-4" title="4">             <span class="dt">ellipse =</span> <span class="ot">FALSE</span>, <span class="dt">show.clust.cent =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb94-5" title="5">             <span class="dt">geom =</span> <span class="st">&quot;point&quot;</span>,<span class="dt">palette =</span> <span class="st">&quot;jco&quot;</span>, <span class="dt">ggtheme =</span> <span class="kw">theme_classic</span>())</a></code></pre></div>
<p><img src="bookdown-demo_files/figure-html/unnamed-chunk-66-1.png" width="672" /></p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="som.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="aprendizaje-semi-supervisado.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/04-dbscan.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["bookdown-demo.pdf", "bookdown-demo.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
